# algorithm

### 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 슈도코드
  - 일반적인 언어로 코드를 흉내 내어 알고리즘을 써 놓은 코드
  - 의사 코드
  - 대략적으로 모델링
- 순서도
  - 진행흐름을 기호나 문자로 나타낸 도표
  - 흐름도
- 정확성, 작업량, 메모리 사용량, 단순성, 최적성
- 성능분석
  - 연산횟수
  - 실제 걸리는 시간
  - **실행되는 명령문 개수**
- 시간 복잡도 - 빅-오 표기법
  - O(2n+1) = O(n)
  - O(2n^2+10n+100) = O(n^2)

---

### list_01

- 배열 : 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- list :  다양한 데이터를 저장, 가변적으로 변경 가능, 2차원 리스트도 가능
- 시퀀스 자료형
  - 순서 존재, 인덱싱, 슬라이싱 연산 모두 적용가능
- len(), +, *, in, not in, min, max, sorted()
- append(), insert(), pop(), remove(), count()
- list comprehension
- [i for i in list if i%2==0]

---

### 완전검색

- Exhaustive Search
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force, Generate-and-Test
- 순열(Permutation)
- nPr = n!

---

### 탐욕 알고리즘

- Greedy Algorithm
- 최적해를 구하는데 사용되는 근시안적인 방법
- 그순간에 최적
- 지역적으로 최적
- 부분 해 집합
- 문제의 제약 조건 위반 여부
- 문제의 해 인지 확인, 해가 아니면 부분 해 집합 선택 순서로 돌아감

---

### 정렬

- sort

- 2개 이상의 자료를 특정 기준에 의해 오름차순 혹은 내림차순 재배열

- 키 - 자료를 정렬하는 기준

- 버블, 카운팅, 선택, 삽입, 병합, 퀵

- 버블

  - 인접한 두개 비교 자리교환 방식

  - ```python
    a = [0,4,1,3,1,2,4,1]
    for i in range(len(a)-1,0,-1):
        for j in range(0,i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
    print(a)
    ```

- 카운팅 정렬

  - 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

  - ```python
    a = [0,4,1,3,1,2,4,1]
    b = [0]*len(a)
    c = [0]*(max(a)+1)
    for i in range(0,len(a)):
        c[a[i]] += 1
        # c = [0,0,0,0,0]
        # c = [1,3,1,1,2]
        
    for i in range(1,len(c)):
        c[i] += c[i-1]
        # c = [1,3,1,1,2]
        # c = [1,4,5,6,8]
        
    for i in range(len(b)-1,-1,-1):
        b[c[a[i]]-1] = a[i]
        c[a[i]] -= 1
        
    print(b)
    ```

---

