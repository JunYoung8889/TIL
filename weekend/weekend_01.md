# 1과목 소프트웨어 설계

### 00. 주간컴공

- 유튜브 - 주간컴공 - 정보처리기사 필기[2020] -1과목(소프트웨어 설계)
- [주간컴공](https://www.youtube.com/watch?v=oW2hMQTVgfw&list=PLKpxllD6C8CnkSWfqRJsHOYtbBFnvtrcY&index=1)

---

### 01. 소프트웨어 생명 주기_1장

- 소프트웨어 생명 주기 : 소프트웨어 개발과정을 단계별로 나눈 것
- 폭포수 모델 : 각 단계를 한번씩만 거침 (**되돌릴 수 없음**)
  - 단계별 철저한 검증 필요 / **매뉴얼 작성 필요**
- 프로토타입 모델 : **기능적 인터페이스 중심**으로 견본 개발 후 최종 개발
  - 추 후 발견 될 오류 방지
- 나선형 모델 : 계획 - 분석(검증) - 개발 - 평가(오류방지)의 단계를 반복
  - Spiral Model 스파이럴 모델
  - 폭포수와 프로토아입의 장점 흡수하여 점진적 개발
  - **대규모** 소프트웨어 개발에 용이
- 애자일 모델 : 요구사항 반영 및 고객과의 의사소통 빈도를 **높이는 것이 목표**
  - Agile Model
  - 협업, 상호작용
  - 여러 개발방법을 아우르는 모델

---

### 02. 스크럼 기법_1장

- 스크럼 기법 : 팀 중심, 제품 책임자, **스크럼** 마스터, 개발팀으로 구성
- 제품 책임자(PO) : 의사 결정자, 백로그의 우선순위 지정
- 스크럼 마스터 : **일일 회의 주관**, 개발 가이드
- 개발팀 : **개발자 뿐 아니라** 디자이너, 테스터 등 **모든 인원**
- 프로세스
  - 백로그 : 요구사항을 우선순위에 따라 모아놓은 목록
  - 계획 회의 : 스프린트 일정 수립, 개발자 별로 스프린트 백로그 작성
  - 스프린트 진행 : 할 일, 진행 중, 완료
  - 일일 회의 : 스크럼 마스터 주도, **소멸차트 활용**
  - 검토 회의 : 주별, **제품 책임자(PO) 주도**, 백로그 업데이트
  - 회고 : 지난 일정 되돌아보기, 개선점 찾기

---

### 03. XP 기법_1장

- 짧고 반복적인 개발 주기, 고객의 적극적 참여를 통한 가시성 향상
- **소규모** 인원의 개발 프로젝트에 효과적
- 핵심가치 : 피드백, 존중, 용기, **단순화,** 소통 -  **XP 피존용단소**
- 개발 프로세스
  - 사용자 스토리 : 고객의 요구사항
  - 릴리즈 계획 수립 : **부분과 전체**의 개발 일정 수립
  - 스파이크 : 기술 및 기능확인을 위해 간단히 만드는 **프로그램**
  - 이터레이션 : **릴리즈**를 좀 더 세분화 한 단위
  - 승인 검사 : 부분 소프트웨어가 릴리즈 되면 고객이 직접 평가
  - 소규모 릴리즈 : 릴리즈 별로 고객의 피드백 확인 가능

---

### 04. 현행 시스템 파악_1장

- 시스템 파악 : 시스템 개발 범위를 명확하게 설정
  - 시스템 구성 : 기간(주요) 업무와 지원 업무의 주요 기능 파악
  - 시스템 기능 : 주요 기능별 세부 기능들을  **계층형**으로표시
  - 시스템 인터페이스 : 주고받는 데이터의 형식, 프로토콜 파악
  - 아키텍처 구성 : **주요 업무** 시스템의 구성과 동작 원리를 표현
  - 소프트웨어 구성 : 종류 및 라이선스의 적용방식과 **개수**
  - 하드웨어 구성 : **서버**의 주요 사양과 수량, 이중화 적용 여부
  - 네트워크 구성 : 구성도 작성, **물리적 위치**, 보안 취약점, 유지보수

---

### 05. 개발 기술 환경 파악_1장

- 운영체제(OS) : 시스템 자원 관리, 하드웨어 제어를 위한 인터페이스
  - 고려사항 : **주변기기** 지원여부
- DBMS : 데이터베이스 관리를 위한 시스템, 종속성과 중복성 해결
  - DB에 대한 모든 권한과 책임이 있음
  - 고려사항 : 상호 호환성, 데이터 **이중화**
- WAS : 동정 콘텐츠 처리를 위한 미들웨어, **DB서버**와 연동
  - 미들웨어 : 서버와 클라이언트 중간에 위치, **클라이언트** 대신 복잡한 처리를 하기 위함
  - 고려사항 : 다양한 옵션
- 공통 고려사항 : 가용성, 성능, 비용, 기술지원
- 오픈소스 : 라이선스 종류, 기술 지속가능성, 사용자 수

---

### 06. 요구사항 정의 분석 확인_1장

- 요구사항 : 서비스에 대한 설명 및 제약조건
  - 기능 : 기능 자체
  - 비기능 : 기능의 품질, 제약사항
  - 사용자 : **쉬운 표현** 사용
  - 시스템 : 개발자 입장, 전문용어
- 요구사항 개발 프로세스 : 도출(**의사소통**) -> 분석 -> 명세(문서화) -> 확인
  - 분석 : 타당성 조사, 특정 기준으로 분류
    - 개념 모델링 : 단순화, 개념적 표현, 객체간 관계와 **종속성** 분석
    - 협상 : 기능과 비기능, 필요자원, 서로의 요구사항이 충돌하는 경우
    - 정형분석 : 마지막 단계, **구문과 의미**를 갖는 언어 사용, 수학적 기호로 표현
  - 확인 : 검증
    - 검토 : 일반적, 고객대표 포함
    - 모델 검증 : **정적(논리적)** 검증, 실행 안함
    - 프로토타이핑 : 지속적인 프로토타입 작성, 사전 피드백
      - 단점 : 프로토타입에만 집중, 비용부담, 과대평가
    - 인수 테스트 : 사용자 입장에서 요구사항 체크(계획 필요)

---

### 07. UML(Unified Modeling Language)

- 구조적 다이어그램

- |    종류     |      키워드      |
  | :---------: | :--------------: |
  |   클래스    |       구조       |
  |    객체     |       관계       |
  |  컴포넌트   | 구현, 인터페이스 |
  |    배치     |    구현, 위치    |
  | 복합체 구조 |    내부 구조     |
  |   패키지    |       그룹       |

- 행위 다이어그램

- |     종류      |     키워드      |
  | :-----------: | :-------------: |
  |  유스케이스   |     모델링      |
  |    시퀀스     |     메시지      |
  | 커뮤니케이션  | 메시지+연관관계 |
  |     상태      |    상태 변화    |
  |     활동      |    로직 흐름    |
  | 상호작용 개요 |    제어 흐름    |
  |    타이밍     |    시간 제약    |

- 배치 다이어그램

  - 물리적인 자원의 **위치**를 표시하는 것으로 **구현 단계**에서 사용되는 것은?

- 그룹

  - 사물의 종류 중, (구조, 행동, 주해)를 제외한 나머지 하나는?

- 배치 다이어그램 ( - 구조적 다이어그램 / 시퀀스, 상태, 활동 - 행위 다이어그램 )

  - (시퀀스, 상태, 배치, 활동)중, 동적인 행위를 표현하기 위한 것이 아닌 것은?

- 컴포넌트, 배치

  - UML 다이어그램 중, 구현 단계에서 사용하기 적절한 것은?

- 점선 화살표

  - 의존, 실체화 관계에서 처럼, 일시적인 관계를 표현할 때 사용되는 선은?

- 다중도 표현에서 ('다수', '또는')에 해당하는 기호는?

  - `* / .. `

- 포함관계

  - 자동차와 열쇠의 관계를 표현하기 가장 적절한 관계는?

---

### 08. 사용자 인터페이스_2장

- 사용자 인터페이스의 3가지 분야 : 제어, 구성, **기능**
- 사용자 인터페이스의 특징
  - 만족도에 큰 영향을 끼치기 때문에, **가장 많이 변경된다.**
  - 편리성과 가독성, 이해도를 높인다.
  - 최소한의 노력으로 결과를 얻을 수 있도록 한다.
  - **소프트웨어** 아키텍처를 숙지해야 한다.
- 사용자 인터페이스의 구분 : CLI(텍스트), GUI(마우스), NUI(말, 행동)
- 사용자 인터페이스의 기본 원칙 : 직관, 유효, 학습, 유연
- 사용자 인터페이스의 설계 지침
  - 사용자 중심, 일관성, 다순성, 결과 예측 가능, 표준화, 접근성
  - 명확성, 가시성, 오류 발생 해결

---

### 09. UI 표준 및 지침_2장

- O
  - 모든 콘텐츠는 시각적으로 구분 될 수 있도록 설계해야 한다.
  - 용도를 정확하게 이해 할 수 있도록 텍스트를 제공해야 한다.
  - 웹 서비스에서는 비표준 문법에 대한 확장성은 고려하지 않는다.
- X
  - 콘텐츠에 포함 된 소리는 자동으로 재생되어야 한다.
  - 전체 내용을 한꺼번에 볼 수 있도록 되도록 많은 메뉴를 만들어야 한다.
  - 광과민성 발작(초당3~50회 깜빡임으로 인한)은 고려하지 않아도 된다.
  - 모든 웹 문서에 반드시 문서 타입을 명시 할 필요는 없다.
  - 주로 쓰이는 설치 환경을 중점적으로 고려해서 제작한다.

---

### 10. UI 설계 도구_2장

- 표준 및 지침에 따라 UI를 제작하기 위해선 설계도가 필요
- 설계도는 결과물에 대해 미리보기 기능을 함
- 와이어프레임 : 뼈대(레이아웃) 배치, 화면단위
- 목업 : 실제 화면과 유사. 기능 구현 아님.
- 스토리보드 : 와이어프레임 + 콘텐츠 설명(Description), 이동경로
  - 작업 지침서 활용(Description은 세부적 작성 필요)
- 프로토타입 : 인터렉션 적용(동적인 형태)
- 유스케이스 : 사용자 요구사항(기능적)을 다이어그램 형식으로 문서화
  - 각각의 유스케이스에 대한 명세서 작성

---

### 11. UI 요구사항 확인_2장

- O
  - 인터뷰를 통해 사업적, 기술적인 요구사항을 명확히 한다.
  - 활동 사항을 정의할 때는 서로 협의를 통해 진행한다.
  - 요구사항은 정황 시나리오를 토대로 작성한다.
- X
  - 그룹별 인터뷰를 통해 가능한 많은 사람들과 인터뷰를 진행한다.
    - 그룹별 x 개별o
  - 가능한 리서치를 진행한 후 인터뷰를 해야 보다 효율적이다.
    - 인터뷰 후 리서치
  - 요구사항의 작성은 개발자 중심으로 하여 개발에 편리하도록 한다.
    - 사용자 중심
  - UI 요구사항 중 가장 먼저 기능에 대한 정리를 진행한다.
    - 데이터 먼저

---

### 12. 품질 요구사항_2장

- |   기능   |   신뢰   | 사용 | 효율 | 유지보수 | 이식 |
  | :------: | :------: | :--: | :--: | :------: | :--: |
  |   적절   |   성숙   | 이해 | 시간 |   분석   | 적용 |
  |   정확   |   회복   | 학습 | 자원 |   변경   | 설치 |
  |   호환   | 고장허용 | 운용 |      |   시험   | 대체 |
  | 상호운용 |          | 친밀 |      |   안정   | 공존 |
  |   보안   |          |      |      |          |      |

- 기능

  - 적정한 기능이 정확하게 + 호환, 보안
  - 적절성, 정확, 상호운용, 보안, 호환

- 신뢰

  - 고장이 나도 문제없어!!
  - 성숙성, 고장허용성, 회복성

- 사용

  - 얼마나 쉽고 편한지
  - 이해, 학습, 운용, 친밀

- 효율

  - 한정된 시간, 자원으로 많은 일 처리
  - 시간, 자원

- 유지보수

  - 개선 및 확장
  - 분석, 변경, 시험, 안정

- 이식

  - 다른 환경에서 적용
  - 적용, 설치, 대체, 공존

---

### 13. UI 프로토타입 제작 및 검토

- UI 프로토타입
  - 동적인 형태(실제 동작하는 것처럼)의 테스트 모델
  - 필수 기능을 포함, 간단하게, 실 사용자 테스트로 기능 검증
- 장단점
  - 이해와 오류발견이 쉽다
  - 자원소모, 생략 가능성
- 종류
  - 페이퍼 (손으로)
    - 저렴, 즉시, 간단
  - 디지털 (SW로)
    - 결과와 비슷, 테스트 및 수정, 어려움
- 고려사항
  - 계획
    - 목적 - 환경 - 핵심 UI - 인원 - 검증 - 해결 - 가이드
  - 작성
    - 범위확인 - 목표확인 - 자원확인
- 제작단계
  - 요구사항 분석 - 요구사항 작성(프로토타입)
  - 사용자 테스트 및 수정 - 사용자 피드백 및 승인 (반복)

---

### 14. UI 설계서 작성_2장

- 표지
  - 프로젝트(시스템)명
- 개정이력
  - 초안작성 이후 변경할 때마다 버전 0.1씩 증가
- 요구사항 정의서
  - 요구사항 별 적용여부 기록
- 시스템 구조
  - 전체 시스템(사용자, 관리자 등)의 구조 설계
- 사이트 맵
  - 전체 콘텐츠 메뉴별 구성 + 표 형태로 작성
- 프로세스 정의서
  - 사용자 입장에서 작업이 진행되는 순서도
- 화면 설계
  - 각 화면별로 표지 + 스토리보드

---

### 15. UI 유용성평가, 상세설계, 감성공학

- 유용성 평가
  - 뜻
    - 사용자 입장에서 얼마나 유용한지
  - 실행(기능)
    - 불필요, 중복, 불편, 어려운
  - 결과(평가)
    - 즉각적이지 않은 피드백, 결과 이해, 파악이 어려움
- 상세 설계
  - 시나리오
    - 순서도나 계층구조로 작성
  - 일반규칙
    - 기능, 구조, 인터렉션(상호작용), 예외처리 (이후 세부기능 정의)
  - 기대효과
    - 긍정적인 문장과 단어 (완전, 일관, 이해 등..)
- 감성공학
  - HCI
    - 편리하고 안전한 시스템개발(최적의 UX가 목표)
  - UX
    - 시스템 이용 경험. 주관적임(객관적인 UI편리성과 반대개념)
  - 감성공학
    - 감성적, 인간친화적 개발

---

### 16. 소프트웨어 아키텍처_3장

- SW 아키텍처
  - 뜻
    - 기본 구조, 개발 기반
  - 역할
    - 품질유지, 원칙, 지침
  - 모듈
    - 부품(나중에 자세히 배움)
- 기본원리
  - 모듈화
    - 유지관리에 좋음. (많으면 통합비용 상승, 적으면 개발비용 상승)
  - 추상화
    - 포괄적 개념. 구체화 하기 위해 필요. 가성비. 구조파악 용이
  - 단계적 분해
    - 하향식. 추상화의 반복으로 더 많은 단계의 분해 가능
  - 정보은닉
    - 접근금지. 별도의 인터페이스 사용. 유지보수에 용이.
- 품질속성
  - 시스템(성능, 보안) / 비즈니스(비용, 자원) / 아키텍처(결함)
- 설계과정
  - 목표 - 시스템타입 - 아키텍처패턴 - 시스템구체화 - 검토
  - 아키텍처패턴
    - 미리 만들어 둔 공식(다음에 자세하게 배움)

---

### 17. 아키텍처 패턴_3장

- 레이어
  - 상/하위 계층끼리 상호작용
- P2P
  - 서버와 클라이언트 역할 변경가능
- 모델 - 컨트롤러-뷰
  - 대화형 어플리케이션에 적합
- 서버 - 클라이언트
  - 1 대 다 / 항시대기 / 독립적 기능
- 파이프 - 필터
  - 재사용, 확장, 변환, 동기화, 버퍼링
- 블랙보드
  - 공유 데이터 검색, 인식, 식별

---

### 18. 객체지향_3장

- 절차지향
  - 데이터
    - 상수, 변수, 배열, 구조체
  - 기능
    - 실행문, 분기문, 반복문, 함수
- 클래스
  - 구조체와 함수 (데이터와 기능)을 묶어서 캡슐화
  - 정보은닉
  - 재사용
    - 인스턴스, 객체(오브젝트)
  - 확장(유지보수)
    - 상속
  - 다형성
    - 메소드 오버라이딩

---

### 19. 모듈_3장

- 효과적인 모듈 설계 방안
  - 결합도 낮게 + 응집도 높게 = 독립성 높게 = 재사용성 높게
  - 복잡도 낮게 + 중복성 낮게 + 입출력 낮게 = 품질 높게
  - 독립적이고, 단순해야 한다.
- 모듈
  - 뜻
    - 모듈화 된 기능. 서브루틴, 서브 시스템 등으로도 불림
    - 재사용 가능
  - 독립성 판단
    - 약한 결합도와 강한 응집도, 품질과 연관
- 결합도
  - 뜻
    - 모듈간 상호 의존(영향을 미치는) 정도
  - 종류
    - 자료 : 데이터
    - 스탬프 : 자료구조
    - 제어 : 제어요소
    - 외부 : 외부참조
    - 공유 : 공통 데이터
    - 내용 : 내부 직접 참조
- 응집도
  - 뜻
    - 정보은닉 개념 확장, 내부 요소들끼리의 관련 정도
  - 종류
    - 기능 : 단일 연결
    - 순차 : 이전 출력 - 다음 입력
    - 통신 : 동일 입출력 다른 기능
    - 절차 : 다수의 기능을 순차적으로
    - 논리 : 유사한 기능 모음
- 팬
  - 인
    - 해당 모듈을 제어하는 들어오는 화살표
  - 아웃
    - 해당 모듈이 제어하는 나가는 화살표
- 공통모듈
  - 명세기법
    - 정확 : 필요성
    - 명확 : 비중의적
    - 완전 : 필요한 모든 것
    - 일관 : 중복 방지
    - 추적 : 출처/관계 파악

---

### 20. 코드&디자인패턴_3장

- 코드
  - 일정한 규칙에 따라 만들어진 기호
  - 식별, 분류, 배열
  - 순차
    - 숫자가 차례대로 입력되어 있는 일련번호와 같음
    - 혼자 쓰이진 않고 다른 개념들에 더해서 사용
  - 블록
    - 구역을 구분한뒤에 순차코드를 붙이는 것\
  - 10진 코드
    - 항목들을 10진분할, 1자리
  - 그룹분류
    - 10진 분할이랑 유사, 하이픈으로 구분
    - 2자리 이상의 일련번호 부여가 가능
  - 연상
    - LG-OLED50
    - 코드만 봐도 어떤 제품인지 연상이 되는 형태
  - 표의숫자
    - R 300 - 400 - 600
    - 색상 가로 세로 깊이
    - 해당 제품의 수치 등을 코드에 사용한 것

- Facade(퍼싸드)
  - wrapper 객체통해 서브클래스 이용
  - 다수의 서브 클래스들의 통합 인터페이스를 제공할 수 있는 wrapper 객체
- Prototype(프로토타입)
  - 원본 복제, 비용(자원)이 저렴
- Command(커멘드)
  - 요청에 필요한 명령어를 객체화하여 로그에 기록하는 형식
  - 명령을 입력한 뒤에 위쪽 화살표를 누르면 해당 명령어가 바로 입력됨
- Observer(옵저버)
  - 상태가 변하면 전달, 이벤트 발행, 구독
  - 객체 상태가 변하면 상속중인 다른 객체들에게 전달하는 형태
- Adaptar(어뎁터)
  - 서로 일치하지 않는 인터페이스 변환
- Factory Method(팩토리 메소드)
  - 객체를 하위 클래스에서 구체화
  - 상위 클래스는 인터페이스만 제공
  - 각각의 하위 클래스가 서로 다른 작업수행이 가능
- Abstract Factory(추상 팩토리)
  - 상위 클래스의 생성코드를 하위 클래스가 상속받습니다.
  - 상위 클래스의 코드가 변경되면 상속중인 모든 하위 클래스들 역시 전부 변경 가능
  - 하위 클래스에 의존하지 않는 형태
  - 객체 생성코드가 상위 클래스에 존재. 하위(구체화) 클래스가 받아 씀
- Builder(빌더)
  - 분리 된 인스턴스를 조합하여 객체 생성
  - 생성과 표현을 분리
  - 같은 객체를 생성해도 다른 결과를 도출할 수 있는 형태
- Singleton(싱글톤)
  - 클래스 내 인스턴스 하나뿐임을 보장. 동시 참조 불가능
- Bridge(브릿지)
  - 기능을 정의하는 추상층과 구체화하는 구현층을 서로 분리하여 독립적 확장
- Composite(컴포지트)
  - 단일과 복합 객체를 구분없이 하나의 묶음으로 다루기 위해서 트리구조 구성.
- Decorator(데코레이터)
  - 클래스에 기능을 추가하기 위해 다른 객체를 덧붙이는 형태
- Flyweight(플라이웨이트)
  - 다수의 유사 객체 생성이 필요할 때, 메모리 절약을 위해
  - 매번 객체를 생성하지 않고 최대한 공유해서 사용을 하는 형태
- Proxy(프록시)
  - 접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할을 수행
- Chain of Responsibility(책임 연쇄)
  - 둘 이상의 객체가 고리처럼 연결되어서 차례로 실행이 된다면
  - 해당 결과에 대한 책임 역시 차례대로 넘어감
- Interpreter(인터프리터)
  - 문법 표현을 정의. 맞춤법 검사
- Iterator(반복자)
  - 접근이 잦은 객체는 동일한 인터페이스 사용하도록 목적지 까지 순차접근
- Mediator(중재자)
  - 복잡한 상호작용 캡슐화
  - 결합도를 낮추기 위해 사용
- Memento(메멘토)
  - 특정 시점의 상태 객체화, 되돌리기
  - 컨트롤 + z
- State(상태)
  - 이벤트를 객체 상태에 따라 다르게 처리해야 할 때 사용
- Strategy(전략)
  - 동일 계열의 알고리즘을 개별적으로 객체화하여 상호 교환합니다.
  - 각각 독립적으로 사용이 가능하여 서로 영향없이 변경이 가능
- Template Method(탬플릿 메소드)
  - 상위 클래스에서 인터페이스를 정의하고, 하위 클래스에서 인터페이스 구체화
  - 코드의 유지보수가 쉬워짐
- Vistor(방문자)
  - 처리 기능을 별도의 클래스로 분리하는 패턴
  - 데이터 구조와 기능을 분리하는 형태

---

### 21. 시스템 인터페이스 요구사항 분석/검증_4장

- 구성
  - 이름, 시스템, 범위(내용), 방식, 송신 데이터, 인터페이스 주기, 고려사항
- 요구사항 선별
  - 별도의 인터페이스 요구사항 목록 제작
- 자료 준비
  - 시스템 인터페이스 요구사항과 관련된 자료 준비
- 요구사항 분류
  - 기능적 / 비기능적 요구사항으로 분류
- 분석 및 수정
  - 내용을 추가 및 수정 / 세분화 / 우선순위 부여
- 요구사항 검토 계획
  - 기준과 방법, 참여자, 체크리스트, 관련자료, 일정 등
- 검증 방법
  - 동료검토, 워크스루(사전검토 후 회의), 인스펙션(검토 전문가)
  - 프로토타입 제작 / 관련 툴 사용
- 검증 항목
  - 완정성(누락여부) / 일관성(충돌여부) / 명확성(이해여부)
  - 기능성 / 검증가능성/ 추적가능성/ 변경용이성

---

### 22. 인터페이스 시스템 식별, 송/수신 데이터 식별

- 개발 시스템 식별
  - 개발하고자 하는 시스템 정보
- 내/외부 시스템 식별
  - 개발 시스템과 연계할 내/외부 시스템 정보
- 내/외부 시스템 환경 및 관리 주체 식별
  - 운용환경(IP, URL, PORT,...)과 담당자 정보
- 내/외부 시스템 네트워크 연결 정보 식별
  - 인증 및 DB정보
- 인터페이스 식별
  - 시스템과 연계 할 시스템 사이의 인터페이스 정보
- 인터페이스 시스템 식별
  - 송신, 수신 시스템 구분(대외, 내외 구분)
- 인터페이스 표준 항목
  - 교환범위 확인, 인터페이스 표준 항목에 대한 송/수신 데이터 식별
- 코드성 데이터 항목 식별
  - 양쪽 코드가 동일한 경우 : 공통 코드
  - 양쪽 코드가 다른경우 : 양쪽 코드 정보 필요

---

### 23. 인터페이스 방법 명세화/설계서 작성

- DB Link
  - 기본제공. Db Link 객체 이용
- API
  - DB를 읽어오도록 만들어 둔 인터페이스 프로그램
- 연계 솔루션
  - EAI 서버와 각 시스템에 설치 된 클라이언트를 통해 데이터 통신
  - 모니터링 및 통제기능
- Socket
  - 포트할당, 클라이언트와 연결
- Web Service
  - SOAP(Simple Object Access Protocol)
  - WSDL(Web Services Description Language)
  - UDDI(Universal Description, Discovery, and Integration)
- 단방향
  - 요청
  - 응답없음
- 동기
  - 요청 및 대기
  - 응답
- 비동기
  - 요청 및 미대기
  - 응답
- 실시간 방식
  - 즉시 처리
  - 예매, 카톡
- 지연 처리 방식
  - 처리시간 여유
  - 즉시 처리시 비용문제
  - 본인인증 문자
- 배치 방식
  - 일괄 처리
  - 모아뒀다가 대량으로 한번에
  - 세금 계산

---

### 24. 미들웨어 솔루션 명세

- DB - DataBase(커넥터)
  - 2티어 아키텍처 - 물리적으로 2개의 계층
  - 레이어는 논리적 계층

- RPC - Remote Procedure Call
  - 멀리 떨어진 프로시저를 내 시스템의 프로시저처럼 호출할 수 있게 해주는 미들웨어
- MOM - Message Oriented Middleware
  - 메시지 지향 미들웨어
  - 비동기 메시지를 전달하는 방식을 사용하는 미들웨어
  - 이기종 분산 데이터 시스템의 동기화에 많이 사용됨
  - 클라우드 스토리지
- TPm - Transaction Processing Monitor
  - 빠른 응답이 필요한 온라인 트랜잭션 업무에 필요
  - 트랜잭션 - 한번에 실행하는 여러 작업들
  - 유지관리 수월 3티어
- ORB - Object Request Broker
  - 브로커 방식 CORBA 표준 스펙구현
  - 객체를 생성하고 배포, 관리하는 미들웨어
- WAS - Web Application Server
  - 동적인 콘텐츠를 처리하는 웹 환경에 필요한 미들웨어



